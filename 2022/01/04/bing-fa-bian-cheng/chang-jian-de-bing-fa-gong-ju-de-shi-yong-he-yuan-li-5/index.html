<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="常见的并发工具的使用和原理(5), railsoil">
    <meta name="description" content="5. 常见的并发工具的使用和原理Condition 在前面学习synchronized 的时候,有讲到 wait/nofity 的基本使用,结合synchronized 可以实现对线程的通信.那么既然J.U.C 里面提供了锁的实现机制,那么">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>常见的并发工具的使用和原理(5) | railsoil</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="railsoil" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>




<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">railsoil</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">railsoil</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        
    </ul>
</div>


        </div>

        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/14.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">常见的并发工具的使用和原理(5)</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                          <div class="article-tag">
                            <span class="chip bg-color">无标签</span>
                          </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" class="post-category">
                                并发编程
                            </a>
                        
                            <a href="/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" class="post-category">
                                并发编程
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2022-01-04
                </div>
                

                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    7.1k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    30 分
                </div>
                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">

        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="5-常见的并发工具的使用和原理"><a href="#5-常见的并发工具的使用和原理" class="headerlink" title="5. 常见的并发工具的使用和原理"></a>5. 常见的并发工具的使用和原理</h1><h2 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h2><p> 在前面学习synchronized 的时候,有讲到 wait/nofity 的基本使用,结合synchronized 可以实现对线程的通信.那么既然J.U.C 里面提供了锁的实现机制,那么J.U.C 里面有没有提供了类似的线程通信的工具呢? 于是发现了Condition 工具类</p>
<p> Condition 是一个多线程协调通信的工具类,可以让某些线程一起等待某个条件(condition),只有满足条件时，线程才会被唤醒.</p>
<h3 id="Condition的基本使用"><a href="#Condition的基本使用" class="headerlink" title="Condition的基本使用"></a>Condition的基本使用</h3><h3 id="condition-wait"><a href="#condition-wait" class="headerlink" title="condition.wait"></a>condition.wait</h3><p> ConditionWaitDemo</p>
<pre><code>package com.notes.concurrent.lock;

import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;

/**
* @author luyanan
* @since 2019/8/8
* &lt;p&gt;使用condition实现线程wait&lt;/p&gt;
**/
public class ConditionWaitDemo implements Runnable &#123;

   private Lock lock;

   private Condition condition;


   public ConditionWaitDemo(Lock lock, Condition condition) &#123;
       this.lock = lock;
       this.condition = condition;
   &#125;

   @Override
   public void run() &#123;

       System.out.println(&quot;ConditionWaitDemo start &quot;);
       try &#123;
           lock.lock();
           condition.await();
           System.out.println(&quot;ConditionWaitDemo end &quot;);
       &#125; catch (InterruptedException e) &#123;
           e.printStackTrace();
       &#125; finally &#123;
           lock.unlock();
       &#125;

   &#125;
&#125;

</code></pre>
<p> ConditionSignalDemo</p>
<pre><code>package com.notes.concurrent.lock;

import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;

/**
* @author luyanan
* @since 2019/8/8
* &lt;p&gt;使用condition 实现线程唤醒&lt;/p&gt;
**/
public class ConditionSignalDemo implements Runnable &#123;


   private Lock lock;

   private Condition condition;

   public ConditionSignalDemo(Lock lock, Condition condition) &#123;
       this.lock = lock;
       this.condition = condition;
   &#125;

   @Override
   public void run() &#123;

       try &#123;
           System.out.println(&quot;ConditionSignalDemo start &quot;);
           lock.lock();
           condition.signal();
           System.out.println(&quot;ConditionSignalDemo end &quot;);
       &#125; finally &#123;
           lock.unlock();
       &#125;
   &#125;


&#125;
</code></pre>
<p>测试类</p>
<pre><code>package com.notes.concurrent.lock;

import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 * @author luyanan
 * @since 2019/8/8
 * &lt;p&gt;测试类&lt;/p&gt;
 **/
public class ConditionDemo &#123;

    public static void main(String[] args) &#123;
        Lock  lock = new ReentrantLock();
        Condition condition = lock.newCondition();
        new Thread(new ConditionWaitDemo(lock,condition)).start();
        new Thread(new ConditionSignalDemo(lock,condition)).start();
    &#125;

&#125;
</code></pre>
<p> 结果</p>
<pre><code>ConditionWaitDemo start 
ConditionSignalDemo start 
ConditionSignalDemo end 
ConditionWaitDemo end 
</code></pre>
<p> 通过这个案例简单实现了wait和 notify的功能, 当调用await 方法之后,当前线程会释放锁并等待,而其他线程调用confition对象的signal或者signalAll 方法通知被阻塞的线程,然后自己执行unlock 释放锁,被唤醒的线程获得之前是锁继续执行,最后释放锁.</p>
<p> 所以,condition 中两个最重要的方法,一个是await,一个是 signal.</p>
<ul>
<li>await: 把当前线程阻塞挂起</li>
<li>signal: 唤醒阻塞的线程</li>
</ul>
<h3 id="Condition-源码分析"><a href="#Condition-源码分析" class="headerlink" title="Condition 源码分析"></a>Condition 源码分析</h3><p>调用Condition , 需要获得Lock锁,所以意味着会存在一个AQS 同步队列,在上面的案例中,假如两个线程同时运行的话,那么AQS的队列可能是下面四种情况<br><img src="http://files.luyanan.com//img/20190808150135.jpg"><br>那么这个时候,ThreadA 调用了condition.await() 方法之后,它做了什么事情呢?</p>
<h4 id="condition-await"><a href="#condition-await" class="headerlink" title="condition.await"></a>condition.await</h4><p>调用Condition 的await()方法[或者以await开头的方法],会使得当前线程进入到等待队列并释放锁,同时线程状态变为等待状态.当await()方法返回时,当前线程一定获取了Condition 相关联的锁.</p>
<pre><code>   public final void await() throws InterruptedException &#123;
            //  表示await 允许被中断
            if (Thread.interrupted())
                throw new InterruptedException();
            // 创建一个新的节点,节点状态为condition, 采用的数据结构依然为链表,
            Node node = addConditionWaiter();
            //  释放当前的锁,得到锁的状态,并唤醒AQS队列中的一个线程
            int savedState = fullyRelease(node);
            int interruptMode = 0;
            // 判断这个节点是否在AQS队列中,第一次判断的是false, 因为前面已经是释放过锁了.
            while (!isOnSyncQueue(node)) &#123;
                // 通过park 挂起当前线程
                LockSupport.park(this);
                if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)
                    break;
            &#125;
            // 当这个线程醒来之后,会尝试拿锁,当acquireQueued 返回false 就是拿到锁了
            // interruptMode != THROW_IE 表示这个线程没有成功将node 入队,但是signal 执行了enq 方法让其入队了
            // 将interruptMode 设置为 REINTERRUPT
            if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)
                interruptMode = REINTERRUPT;
            // 如果node 的下一个等待着不是null, 则进行清理,清理condition队列上的节点
            // 如果是null,则不需要清理
            if (node.nextWaiter != null) // clean up if cancelled
                unlinkCancelledWaiters();
            // 如果线程被中断了,需要抛出异常,或者什么都不做.
            if (interruptMode != 0)
                reportInterruptAfterWait(interruptMode);
        &#125;
</code></pre>
<h5 id="addConditionWaiter"><a href="#addConditionWaiter" class="headerlink" title="addConditionWaiter"></a>addConditionWaiter</h5><p>这个方法的主要作用是把当前线程封装成Node,添加到等待队列,这里的队列不是双向链表,而是单向链表。</p>
<pre><code>  private Node addConditionWaiter() &#123;
            Node t = lastWaiter;
            // If lastWaiter is cancelled, clean out.
            // 如果laseWaiter 不等于空并且waitStatus 不等于CONDITION的时候,把这个节点从链表中移除
            if (t != null &amp;&amp; t.waitStatus != Node.CONDITION) &#123;
                unlinkCancelledWaiters();
                t = lastWaiter;
            &#125;
            // 构建一个Node, waitStatus = CONDITION, 这里的链表是一个单向链表，相对于AQS来说会简单很多
            Node node = new Node(Thread.currentThread(), Node.CONDITION);
            if (t == null)
                firstWaiter = node;
            else
                t.nextWaiter = node;
            lastWaiter = node;
            return node;
        &#125;
</code></pre>
<p><strong>图解分析</strong></p>
<p>执行完 addConditionWaiter 这个方法之后,就会产生一个这样的condition 队列<br><img src="http://files.luyanan.com//img/20190808162956.png"></p>
<h5 id="fullyRelease"><a href="#fullyRelease" class="headerlink" title="fullyRelease"></a>fullyRelease</h5><p>fullyRelease,就是彻底的释放锁,什么叫彻底呢? 就是如果当前锁存在多次重入,那么在这个方法中只需要释放一次,就会把所有的重入次数归零.</p>
<pre><code> final int fullyRelease(Node node) &#123;
        boolean failed = true;
        try &#123;
            // 获得重入的次数
            int savedState = getState();
            // 释放锁并且唤醒下一个同步队列中的线程
            if (release(savedState)) &#123;
                failed = false;
                return savedState;
            &#125; else &#123;
                throw new IllegalMonitorStateException();
            &#125;
        &#125; finally &#123;
            if (failed)
                node.waitStatus = Node.CANCELLED;
        &#125;
    &#125;
</code></pre>
<h6 id="图解分析"><a href="#图解分析" class="headerlink" title="图解分析"></a>图解分析</h6><p>此时,同步队列会出发锁的释放和重新竞争.ThreadB 获得了锁<br><img src="http://files.luyanan.com//img/20190808164157.jpg"></p>
<h5 id="isOnSyncQueue"><a href="#isOnSyncQueue" class="headerlink" title="isOnSyncQueue"></a>isOnSyncQueue</h5><p>判断当前节点是否在同步队列中，返回false 则表示不在,返回true 则表示在</p>
<p>如果不在AQS同步队列,说明当前节点没有唤醒去争抢同步锁,所以需要把当前线程阻塞起来,直到其他的线程调用signal 唤醒.</p>
<p>如果在AQS同步队列中,意味着它需要同步锁去获得执行程序执行权限。</p>
<p>为什么要做这个判断呢? 原因是在conditin 队列中的节点会重新加入到AQS队列去竞争锁.也就是调用signal的时候,会把当前节点从condition 队列转移到AQS 队列中.</p>
<h6 id="大家思考一下-基于现在的逻辑结构-如何去判断ThreadA-这个节点是否存在于AQS队列中呢"><a href="#大家思考一下-基于现在的逻辑结构-如何去判断ThreadA-这个节点是否存在于AQS队列中呢" class="headerlink" title="大家思考一下,基于现在的逻辑结构.如何去判断ThreadA 这个节点是否存在于AQS队列中呢?"></a>大家思考一下,基于现在的逻辑结构.如何去判断ThreadA 这个节点是否存在于AQS队列中呢?</h6><ol>
<li>如果ThreadA的waitStatus 的状态为CONDITION,说明他存在于condition队列中,不在AQS队列中,因为AQS 队列的状态一定不可能有CONDITION</li>
<li>如果node.prev为空,说明也不存在于AQS队列,原因是prev = null 在AQS队列中只存在一种可能性,就是它是head节点,head节点意味着它是获得锁的节点.</li>
<li>如果node.next 不等于空,说明一定存在于AQS队列中,因为只有AQS队列才会存在next和prev 关系.</li>
<li>findNodeFromTail 表示从tail节点往前扫描AQS队列，一旦发现AQS队列的节点与当前节点一样,说明节点一定存在于AQS队列中.<br>```<br>final boolean isOnSyncQueue(Node node) {<pre><code> if (node.waitStatus == Node.CONDITION || node.prev == null)
     return false;
 if (node.next != null) // If has successor, it must be on queue
     return true;
 /*
  * node.prev can be non-null, but not yet on queue because
  * the CAS to place it on queue can fail. So we have to
  * traverse from tail to make sure it actually made it.  It
  * will always be near the tail in calls to this method, and
  * unless the CAS failed (which is unlikely), it will be
  * there, so we hardly ever traverse much.
  */
 return findNodeFromTail(node);
</code></pre>
 }</li>
</ol>
<pre><code>
#### condition.signal
await 方法会阻塞ThreadA, 然后ThreadB 抢占到了锁获得了执行权限,这个时候在ThreadB 中调用了condition.signal()方法,将会唤醒在等待队列中的节点
</code></pre>
<p>  public final void signal() {<br>            // 先判断当前线程是否获得了锁,这个判断比较简单,直接用获得了锁的线程和当前线程进行相对即可.<br>            if (!isHeldExclusively())<br>                throw new IllegalMonitorStateException();<br>            // 拿到Condition队列上的第一个节点<br>            Node first = firstWaiter;<br>            if (first != null)<br>                doSignal(first);<br>        }</p>
<pre><code>##### doSignal
对 condition 队列中从首部开始的第一个condition状态的节点,执行 transferForSignal 操作,将node 从condition 队列中转换到AQS队列中,同时修改AQS队列中原先队尾 的状态.
</code></pre>
<p>private void doSignal(Node first) {<br>            do {<br>                if ( (firstWaiter = first.nextWaiter) == null)<br>                    // 将next 节点设置为null<br>                    lastWaiter = null;<br>                first.nextWaiter = null;<br>            } while (!transferForSignal(first) &amp;&amp;<br>                     (first = firstWaiter) != null);<br>        }</p>
<pre><code>
##### AQS.transferForSignal
该方法显示CAS 修改了节点状态,如果成功,就将这个节点放到AQS 队列中,然后唤醒这个节点上的线程. 此时,这个节点j就会在await 方法中唤醒.
</code></pre>
<p>  final boolean transferForSignal(Node node) {<br>        /*<br>         * If cannot change waitStatus, the node has been cancelled.<br>         */<br>        // 更新节点的状态为0,如果更新失败,只有一种可能就是节点被CANCELLED 了<br>        if (!compareAndSetWaitStatus(node, Node.CONDITION, 0))<br>            return false;</p>
<pre><code>    /*
     * Splice onto queue and try to set waitStatus of predecessor to
     * indicate that thread is (probably) waiting. If cancelled or
     * attempt to set waitStatus fails, wake up to resync (in which
     * case the waitStatus can be transiently and harmlessly wrong).
     */
    // 调用enq,把当前节点添加到AQS队列中,b并且返回当前节点的上一个节点,也就是原tail节点
    Node p = enq(node);
    int ws = p.waitStatus;
    // 如果上一个节点的状态被取消了,或者尝试设置上一个节点的状态为SIGNAL,失败了(SIGNAL 表示它的next节点需要停止阻塞)
    if (ws &gt; 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))
        // 唤醒节点上的线程
        LockSupport.unpark(node.thread);
    // 如果node的prev 节点已经是signal 状态,那么被阻塞的ThreadA 的唤醒工作由AQS 队列来完成
    return true;
&#125;
</code></pre>
<pre><code>
######  图解分析
执行完doSignal 以后,会把condition 队列中的节点转移到AQS 队列中

这个时候会判断ThreadA的prev 节点也就是head节点的waitStatus,如果大于0 或者设置signal 失败,表示节点被设置成了CANCELLED状态.这个时候会唤醒ThreadA 这个线程,否则就基于AQS 队列的机制来唤醒,也就是等到ThreadB 释放锁之后来唤醒ThreadA

#####  被阻塞的线程唤醒后的逻辑
前面在分析 await方法时,线程会被阻塞.而通过signal 被唤醒后又继续回到上次执行的逻辑中被标注为红色部分的代码

checkInterruptWhileWaiting 这个方法是干啥的呢? 其实从名字上就可以看出来,就是ThreadA 在condition 队列被阻塞的过程中,有没有被其他线程触发过中断请求 .
</code></pre>
<p> public final void await() throws InterruptedException {<br>            //  表示await 允许被中断<br>            if (Thread.interrupted())<br>                throw new InterruptedException();<br>            // 创建一个新的节点,节点状态为condition, 采用的数据结构依然为链表,<br>            Node node = addConditionWaiter();<br>            //  释放当前的锁,得到锁的状态,并唤醒AQS队列中的一个线程<br>            int savedState = fullyRelease(node);<br>            int interruptMode = 0;<br>            // 判断这个节点是否在AQS队列中,第一次判断的是false, 因为前面已经是释放过锁了.<br>            while (!isOnSyncQueue(node)) {<br>                // 通过park 挂起当前线程<br>                LockSupport.park(this);<br>                if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)<br>                    break;<br>            }<br>            // 当这个线程醒来之后,会尝试拿锁,当acquireQueued 返回false 就是拿到锁了<br>            // interruptMode != THROW_IE 表示这个线程没有成功将node 入队,但是signal 执行了enq 方法让其入队了<br>            // 将interruptMode 设置为 REINTERRUPT<br>            if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)<br>                interruptMode = REINTERRUPT;<br>            // 如果node 的下一个等待着不是null, 则进行清理,清理condition队列上的节点<br>            // 如果是null,则不需要清理<br>            if (node.nextWaiter != null) // clean up if cancelled<br>                unlinkCancelledWaiters();<br>            // 如果线程被中断了,需要抛出异常,或者什么都不做.<br>            if (interruptMode != 0)<br>                reportInterruptAfterWait(interruptMode);<br>        }</p>
<pre><code>
###### checkInterruptWhileWaiting
如果当前线程被中断,则调用transferAfterCancelledWait 方法判断后续的处理应该是抛出InterruptedException 异常 还是重新中断

这里需要注意的是,如果第一次CAS 失败了,则不能判断当前线程是先进行了中断还是先进行了signal方法的调用,可能是先执行了signal 然后中断,也可能是先执行了中断,后执行了signal。 当然 这两个操作肯定是发生在CAS之前,这时需要做的就是等待当前线程的node被添加到AQS 队列后，也就是enq方法返回后,返回false 告诉 checkInterruptWhileWaiting 方法返回 REINTERRUPT(1), 后续进行重新中断。

简单来说,该方法的返回值代表当前线程是否在park的时候被中断唤醒,如果为true, 表示中断在siganl调用之前,signal 还未执行. 那么这个时候会根据await() 的语义,在await 时遇到中断需要抛出InterruptedException ,返回true 就是告诉checkInterruptWhileWaiting 返回THROW_IE(-1). 如果返回false ,否则表示siganl 已经执行过了,只需要响应中断即可.
</code></pre>
<pre><code> private int checkInterruptWhileWaiting(Node node) &#123;
        return Thread.interrupted() ?
            (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :
            0;
    &#125;
    
    
 final boolean transferAfterCancelledWait(Node node) &#123;
    // 使用cas 修改节点状态,如果 还能修改成功,说明线程被中断时,signal 还没有被调用
    // 这里有一个知识点,就是线程被唤醒,并不一定是在java层面执行了 lockSupport.unpark,也就是调用了线程的interrupt()方法,这个方法
    // 会更新一个中断标识,并且会唤醒处于阻塞状态下的线程
    if (compareAndSetWaitStatus(node, Node.CONDITION, 0)) &#123;
        // 如果cas成功,则把node添加到AQS队列中
        enq(node);
        return true;
    &#125;
    /*
     * If we lost out to a signal(), then we can&#39;t proceed
     * until it finishes its enq().  Cancelling during an
     * incomplete transfer is both rare and transient, so just
     * spin.
     */
    // 循环检测node是否已经添加到AQS队列中,如果没有,则通过yield
    while (!isOnSyncQueue(node))
        Thread.yield();
    return false;
&#125;
</code></pre>
<pre><code>
##### acquireQueued
这个方法在讲AQS的时候说过,是当前被唤醒的节点ThreadA 去抢占锁,并且要恢复到原本的重入次数状态.调用完这个方法之后,AQS队列的状态如下:将head节点的waitStatus 设置为-1 Signal 状态


##### reportInterruptAfterWait
根据checkInterruptWhileWaiting 方法返回的中断标识来进行中断上报,如果是THROW_IE,则抛出中断异常,如果是REINTERRUPT,则重新响应中断.
</code></pre>
<p>   private void reportInterruptAfterWait(int interruptMode)<br>            throws InterruptedException {<br>            if (interruptMode == THROW_IE)<br>                throw new InterruptedException();<br>            else if (interruptMode == REINTERRUPT)<br>                selfInterrupt();<br>        }</p>
<pre><code>
### Condition 总结
#### await 和 signal 的总结
![](http://files.luyanan.com//img/20190812142913.jpg)

我们把前面的整个分解的图在通过一张整体的结构图来表述,线程awaitThread 先通过lock.lock() 方法 获得锁成功后调用了 condition.await() 方法进入了等待队列中,而另一个线程signalThread通过lock.lock() 方法获得锁成功后调用了condition.signal() 或者signalAll() 方法,使得线程awaitThread 能够有机会移入到同步队列中,当其他线程释放lock 后使得线程 awaitThread 能够有机会获取lock,从而使得线程awaitThread 能够从await 方法中推出执行后续操作.如果awaitThread 获得lock失败会直接进入到同步队列中.

**阻塞:** 在await方法中,在线程释放锁资源后,如果节点不在AQS等待队列,则阻塞当前线程,如果在等待队列,则自旋鞥带尝试获得锁.

**释放:** signal 后,节点会从condition队列移动到 AQS等待队列,则进入正常锁的获得流程.

## CountDownLatch

countDownLatch 是一个同步工具类,它允许一个或者多个线程一直等待,直到其他线程的操作执行完毕再执行.,从命名汇总可以解读到 countdown 是倒数的意思,类似于我们倒计时的概念

countDownLatch 提供了两个方法.一个是 countDown,一个是 await . countDownLatch 在初始化的时候需要传入一个整数,在这个整数倒数到0之前,调用await 方法的线程都必须等待,然后通过countDown 来倒数
</code></pre>
<p>package com.notes.concurrent;</p>
<p>import java.util.concurrent.CountDownLatch;</p>
<p>/**</p>
<ul>
<li><p>@author luyanan</p>
</li>
<li><p>@since 2019/8/12</p>
</li>
<li><p>countDownLatch的demo</p></li>
<li><p>*/<br>public class CountDownLatchDemo {</p>
<p>  public static void main(String[] args) throws InterruptedException {</p>
<pre><code>  CountDownLatch countDownLatch = new CountDownLatch(3);
  new Thread(() -&gt; &#123;
      System.out.println(Thread.currentThread().getName() + &quot;-&quot; + &quot;执行中&quot;);
      countDownLatch.countDown();
      System.out.println(Thread.currentThread().getName() + &quot;-&quot; + &quot;执行完毕&quot;);
  &#125;,&quot;t1&quot;).start();

  new Thread(() -&gt; &#123;
      System.out.println(Thread.currentThread().getName() + &quot;-&quot; + &quot;执行中&quot;);
      countDownLatch.countDown();
      System.out.println(Thread.currentThread().getName() + &quot;-&quot; + &quot;执行完毕&quot;);
  &#125;,&quot;t2&quot;).start();
  new Thread(() -&gt; &#123;
      System.out.println(Thread.currentThread().getName() + &quot;-&quot; + &quot;执行中&quot;);
      countDownLatch.countDown();
      System.out.println(Thread.currentThread().getName() + &quot;-&quot; + &quot;执行完毕&quot;);
  &#125;,&quot;t3&quot;).start();

  countDownLatch.await();
  System.out.println(&quot;所有线程执行结束&quot;);
</code></pre>
<p>  }</p>
</li>
</ul>
<p>}</p>
<pre><code>结果
</code></pre>
<p>t1-执行中<br>t1-执行完毕<br>t2-执行中<br>t3-执行中<br>t3-执行完毕<br>t2-执行完毕<br>所有线程执行结束</p>
<pre><code>从代码的实现上来看,有点类似于join的功能,但是比join  更加的灵活.CountDownLatch 构造函数会接受一个int 类型的参数作为计数器的初始值. 当调用CountDownLatch的 countDown 方法的时候,这个计数器就会减1,通过await方法去阻塞主流程.

#####  模拟高并发
</code></pre>
<p>package com.notes.concurrent;</p>
<p>import java.util.concurrent.CountDownLatch;</p>
<p>/**</p>
<ul>
<li>@author luyanan</li>
<li>@since 2019/8/12</li>
<li><p>使用countDownLatch 模拟高并发</p></li>
<li>*/<br>public class CountDownLatchDemo2 extends  Thread {</li>
</ul>
<pre><code>static CountDownLatch countDownLatch = new CountDownLatch(1);

@Override
public void run() &#123;
    try &#123;
        countDownLatch.await();
    &#125; catch (InterruptedException e) &#123;
        e.printStackTrace();
    &#125;
    System.out.println(&quot;ThreadName:&quot; + Thread.currentThread().getName());
&#125;


public static void main(String[] args) &#123;
    for (int i = 0; i &lt; 1000; i++) &#123;
        new CountDownLatchDemo2().start();
    &#125;
    countDownLatch.countDown();
&#125;
</code></pre>
<p>}</p>
<pre><code> 总的来说,凡是涉及到需要指定某个任务执行之前,需要等待前置任务执行完毕之后才执行的场景,都可以使用CountDownLatch

 #### CountDownLatch的源码分析
 ![](http://files.luyanan.com//img/20190812154533.jpg)
 对于CountDownLatch ,我们仅仅需要关心两个方法,一个是countDown,另一个是 await()方法。

 countDown() 方法每次调用都会将state 减1,知道state 的值为0; 而await方法是一个阻塞方法,当state 减为0的时候,await方法才会返回. await可以被多个线程调用,大家在这个时候脑子里面要有个图: 所有调用了await方法的线程阻塞在AQS队列中,等待条件(state = 0) 满足,将线程从队列中一个个的唤醒过来.

 ##### acquireSharedInterruptibly
 countDownLatch 也用到了AQS,在CountDownLatch 内部写了一个Sync 并且继承了AQS这个抽象类重写了AQS中的共享锁的方法. 首先看到下面这个代码,这段代码主要是判断当前线程是否获取到了共享锁;(在CountDownLatch中使用的是共享锁机制,因为在CountDownLatch 中并不需要实现互斥的特性)
</code></pre>
<p>   public final void acquireSharedInterruptibly(int arg)<br>            throws InterruptedException {<br>        if (Thread.interrupted())<br>            throw new InterruptedException();<br>        // state 如果不等于0,说明当前线程需要加入到共享锁队列<br>        if (tryAcquireShared(arg) &lt; 0)<br>            doAcquireSharedInterruptibly(arg);<br>    }</p>
<pre><code>##### doAcquireSharedInterruptibly
1. addWaiter 设置为shared 模式
2. tryAcquire和tryAcquireShared 的返回值不同,因此会多出一个判断过程.
3. 在判断前驱节点是头节点之后,调用了setHeadAndPropagate方法,而不是简单的更新了一下头节点
</code></pre>
<p>  private void doAcquireSharedInterruptibly(int arg)<br>        throws InterruptedException {<br>        // 创建一个共享模式的节点添加到队列中<br>        final Node node = addWaiter(Node.SHARED);<br>        boolean failed = true;<br>        try {<br>            for (;;) {<br>                final Node p = node.predecessor();<br>                if (p == head) {<br>                    // 判断尝试获得锁<br>                    int r = tryAcquireShared(arg);<br>                    // r &gt;=0 表示尝试获取到了执行权限,这个时候因为 state !=0 ,所以不会执行这段代码<br>                    if (r &gt;= 0) {<br>                        setHeadAndPropagate(node, r);<br>                        p.next = null; // help GC<br>                        failed = false;<br>                        return;<br>                    }<br>                }<br>                // 阻塞线程<br>                if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>                    parkAndCheckInterrupt())<br>                    throw new InterruptedException();<br>            }<br>        } finally {<br>            if (failed)<br>                cancelAcquire(node);<br>        }<br>    }</p>
<pre><code>
######  图解分析

加入这个时候有是三个线程都调用了await方法,由于这个时候state的值还不为0,所以这三个线程都会加入到AQS队列中,并且这三个线程都属于阻塞状态.

![](http://files.luyanan.com//img/20190812163630.jpg)
#### CountDownLatch.countDown

由于线程被await 方法阻塞了,所以只能等到countDown 方法使得state = 0的时候才会被唤醒,我们来看看countDown 做了什么?
1. 只有当state 减为0的时候,tryReleaseShared 才返回true, 否则只是简单的 state = state -1
2. 如果state = 0,  则调用 doReleaseShared 唤醒 处于await 状态下的线程
</code></pre>
<pre><code>protected int tryAcquireShared(int acquires) &#123;
        return (getState() == 0) ? 1 : -1;
    &#125;

    protected boolean tryReleaseShared(int releases) &#123;
        // Decrement count; signal when transition to zero
        // 用自旋的方式实现state 减1
        for (;;) &#123;
            int c = getState();
            if (c == 0)
                return false;
            int nextc = c-1;
            if (compareAndSetState(c, nextc))
                return nextc == 0;
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code>#### AQS.doReleaseShared

共享锁的释放和独占锁的释放是有一定的差别的

前面唤醒锁的逻辑和独占锁是一样的,先判断头节点是不是SIGNAL状态,如果是,则修改为0,并且唤醒头节点的下一个节点.

&gt; PROPAGATE： 标识为PROPAGETE 状态的节点,是共享锁模式下的节点状态,处于这个状态的节点会对线程的唤醒进行传播.
</code></pre>
<p>   private void doReleaseShared() {<br>        /*<br>         * Ensure that a release propagates, even if there are other<br>         * in-progress acquires/releases.  This proceeds in the usual<br>         * way of trying to unparkSuccessor of head if it needs<br>         * signal. But if it does not, status is set to PROPAGATE to<br>         * ensure that upon release, propagation continues.<br>         * Additionally, we must loop in case a new node is added<br>         * while we are doing this. Also, unlike other uses of<br>         * unparkSuccessor, we need to know if CAS to reset status<br>         * fails, if so rechecking.<br>         */<br>        for (;;) {<br>            Node h = head;<br>            if (h != null &amp;&amp; h != tail) {<br>                int ws = h.waitStatus;<br>                if (ws == Node.SIGNAL) {<br>                    if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))<br>                        continue;            // loop to recheck cases<br>                    unparkSuccessor(h);<br>                }<br>                // 这个CAS失败的场景是: 执行到这里的时候,刚好有一个节点入队,入队会将这个ws设置为-1<br>                else if (ws == 0 &amp;&amp;<br>                         !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))<br>                    continue;                // loop on failed CAS<br>            }<br>            // 如果到这里的时候,前面唤醒的线程已经占领了head,那么再循环通过检查头节点是否被改变了,如果改变了就继续循环<br>            if (h == head)                   // loop if head changed<br>                break;<br>        }<br>    }</p>
<pre><code>
- h == head:说明头节点还没有被刚刚用unparkSuccessor唤醒的线程(这里可以理解为ThreadB) 占有,此时break 退出循环.
-  h!= head: 头节点被刚刚唤醒的线程占用,那么这里重新进入到下一轮循环,唤醒下一个节点(这里是ThreadB),我们知道等到ThreadB被唤醒后,其实是会主动唤醒ThreadC...


##### doAcquireSharedInterruptibly
一旦ThreadA被唤醒后,代码又会继续回到doAcquireSharedInterruptibly 中来执行.如果当前state = 0的条件满足,则会执行setHeadAndPropagate 方法
</code></pre>
<p> private void doAcquireSharedInterruptibly(int arg)<br>        throws InterruptedException {<br>        // 创建一个共享模式的节点添加到队列中<br>        final Node node = addWaiter(Node.SHARED);<br>        boolean failed = true;<br>        try {<br>            // 被唤醒的线程进入下一次循环继续判断<br>            for (;;) {<br>                final Node p = node.predecessor();<br>                if (p == head) {<br>                    // 判断尝试获得锁<br>                    int r = tryAcquireShared(arg);<br>                    // r &gt;=0 表示尝试获取到了执行权限,这个时候因为 state !=0 ,所以不会执行这段代码<br>                    if (r &gt;= 0) {<br>                        setHeadAndPropagate(node, r);<br>                        // 把当前节点移除AQS队列<br>                        p.next = null; // help GC<br>                        failed = false;<br>                        return;<br>                    }<br>                }<br>                // 阻塞线程<br>                if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>                    parkAndCheckInterrupt())<br>                    throw new InterruptedException();<br>            }<br>        } finally {<br>            if (failed)<br>                cancelAcquire(node);<br>        }<br>    }</p>
<pre><code>

##### setHeadAndPropagate
这个方法的主要作用是把被唤醒的节点设置成head节点,然后继续唤醒队列中的其他线程.

由于现在队列中有三个线程处于阻塞状态,一旦ThreaA 被唤醒,并且设置成head后,会继续唤醒后续的ThreadB
</code></pre>
<p> private void setHeadAndPropagate(Node node, int propagate) {<br>        Node h = head; // Record old head for check below<br>        setHead(node);<br>        /*<br>         * Try to signal next queued node if:<br>         *   Propagation was indicated by caller,<br>         *     or was recorded (as h.waitStatus either before<br>         *     or after setHead) by a previous operation<br>         *     (note: this uses sign-check of waitStatus because<br>         *      PROPAGATE status may transition to SIGNAL.)<br>         * and<br>         *   The next node is waiting in shared mode,<br>         *     or we don’t know, because it appears null<br>         *<br>         * The conservatism in both of these checks may cause<br>         * unnecessary wake-ups, but only when there are multiple<br>         * racing acquires/releases, so most need signals now or soon<br>         * anyway.<br>         */<br>        if (propagate &gt; 0 || h == null || h.waitStatus &lt; 0 ||<br>            (h = head) == null || h.waitStatus &lt; 0) {<br>            Node s = node.next;<br>            if (s == null || s.isShared())<br>                doReleaseShared();<br>        }<br>    }</p>
<pre><code>######  图解分析
![](http://files.luyanan.com//img/20190812171333.jpg)

## Semaphore

Semaphore 也就是我们常说的信号灯,Semaphore 可以控制同时访问的线程个数,通过acquire 获得一个许可,如果没有就等待，通过release 释放一个许可.有点类似于限流的作用. 叫信号灯的原因也和她的用户有关，比如某商场就5个停车位,每个停车位只能停一辆车,如果这个时候来了10辆车,必须要等到前面有空的车位才能进去.
</code></pre>
<p>package com.notes.concurrent;</p>
<p>import java.util.concurrent.Semaphore;<br>import java.util.concurrent.TimeUnit;</p>
<p>/**</p>
<ul>
<li>@author luyanan</li>
<li>@since 2019/8/12</li>
<li><p>Semaphore demo</p></li>
<li>*/<br>public class SemaphoreDemo {</li>
</ul>
<pre><code>public static void main(String[] args) &#123;
    Semaphore semaphore = new Semaphore(5);
    for (int i = 0; i &lt; 10; i++) &#123;

        new Thread(new Car(i,semaphore)).start();
    &#125;
&#125;

static class Car extends  Thread &#123;

    private int num;

    private Semaphore semaphore;

    public Car(int num, Semaphore semaphore) &#123;
        this.num = num;
        this.semaphore = semaphore;
    &#125;

    @Override
    public void run() &#123;

        try &#123;
            semaphore.acquire();
            System.out.println(&quot;第&quot; + num + &quot;个车位被占用了&quot;);
            TimeUnit.SECONDS.sleep(2);
            System.out.println(&quot;第&quot; + num + &quot;个车位被释放了&quot;);
            semaphore.release();
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;

    &#125;
&#125;
</code></pre>
<p>}</p>
<pre><code>结果
</code></pre>
<p>第0个车位被占用了<br>第2个车位被占用了<br>第1个车位被占用了<br>第3个车位被占用了<br>第4个车位被占用了<br>第4个车位被释放了<br>第1个车位被释放了<br>第0个车位被释放了<br>第5个车位被占用了<br>第7个车位被占用了<br>第3个车位被释放了<br>第2个车位被释放了<br>第8个车位被占用了<br>第9个车位被占用了<br>第6个车位被占用了<br>第8个车位被释放了<br>第5个车位被释放了<br>第7个车位被释放了<br>第6个车位被释放了<br>第9个车位被释放了</p>
<pre><code>
##### 使用场景
Semaphore比较常见的就是用来做限流
##### Semaphore 源码分析
从Semaphore的功能上来看,我们基本能猜测到他的底层一定是基于AQS的共享锁,因为需要实现多个线程共享一个令牌池.

创建Semaphore实例的时候,需要一个参数permit, 这个基本上可以确定是设置给AQS的state的,然后每个线程调用acquire 的时候,执行state = state -1, release的时候执行 state = state +1,当然,acquire的时候,如果state = 0 说明没有资源了,需要等待其他线程release

Semaphore 分公平策略和非公平策略
##### FairSync
</code></pre>
<p>  static final class FairSync extends Sync {<br>        private static final long serialVersionUID = 2014338818796000944L;</p>
<pre><code>    FairSync(int permits) &#123;
        super(permits);
    &#125;

    protected int tryAcquireShared(int acquires) &#123;
        for (;;) &#123;
            // 区别在于是不是会先判断是否有线程在排队,然后才进行CAS 减操作
            if (hasQueuedPredecessors())
                return -1;
            int available = getState();
            int remaining = available - acquires;
            if (remaining &lt; 0 ||
                compareAndSetState(available, remaining))
                return remaining;
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code>##### NofairSync
</code></pre>
<p> static final class NonfairSync extends Sync {<br>        private static final long serialVersionUID = -2694183684443567898L;</p>
<pre><code>    NonfairSync(int permits) &#123;
        super(permits);
    &#125;

    protected int tryAcquireShared(int acquires) &#123;
        return nonfairTryAcquireShared(acquires);
    &#125;
&#125;

       final int nonfairTryAcquireShared(int acquires) &#123;
        for (;;) &#123;
            int available = getState();
            int remaining = available - acquires;
            if (remaining &lt; 0 ||
                compareAndSetState(available, remaining))
                return remaining;
        &#125;
    &#125;
</code></pre>
<pre><code>## CyclicBarrier

CyclicBarrier 的字面意思是可循环使用(Cyclic)的屏障(Barrier).他要做的事情是让一组线程到达一个屏障(也可以叫同步点)时被阻塞,知道最后一个线程达到屏障时,屏障才会开门,所有被屏障拦截的线程才会继续工作. CyclicBarrier的默认的构造方法是CyclicBarrier(int parties),其参数表示屏障拦截的线程数量,每个线程调用await方法告诉 CyclicBarrier 当前线程已经达到了屏障,然后当前线程被阻塞.

##### 使用场景
当存在需要所有的子任务都完成时,才执行主任务,这个时候就可以选择使用CyclicBarrier
##### 使用案例
DataImportThread
</code></pre>
<p>package com.notes.concurrent.cyclicbarrier;</p>
<p>import java.util.concurrent.BrokenBarrierException;<br>import java.util.concurrent.CyclicBarrier;</p>
<p>/**</p>
<ul>
<li><p>@author luyanan</p>
</li>
<li><p>@since 2019/8/12</p>
</li>
<li><p></p></li>
<li><p>*/<br>public class DataImportThread extends Thread {</p>
<p>  private CyclicBarrier cyclicBarrier;</p>
</li>
</ul>
<pre><code>private String path;

public DataImportThread(CyclicBarrier cyclicBarrier, String path) &#123;
    this.cyclicBarrier = cyclicBarrier;
    this.path = path;
&#125;

@Override
public void run() &#123;

    System.out.println(&quot;开始导入:&quot; + path + &quot;位置的数据&quot;);

    try &#123;
        cyclicBarrier.await();
    &#125; catch (InterruptedException e) &#123;
        e.printStackTrace();
    &#125; catch (BrokenBarrierException e) &#123;
        e.printStackTrace();
    &#125;


&#125;
</code></pre>
<p>}</p>
<pre><code>CycliBarrierDemo
</code></pre>
<p>package com.notes.concurrent.cyclicbarrier;</p>
<p>import java.util.concurrent.CyclicBarrier;</p>
<p>/**</p>
<ul>
<li><p>@author luyanan</p>
</li>
<li><p>@since 2019/8/12</p>
</li>
<li><p></p></li>
<li><p>*/<br>public class CycliBarrierDemo extends Thread {</p>
<p>  @Override<br>  public void run() {</p>
<pre><code>  System.out.println(&quot;开始进行数据分析&quot;);
</code></pre>
<p>  }</p>
</li>
</ul>
<pre><code>public static void main(String[] args) &#123;
    CyclicBarrier cyclicBarrier = new CyclicBarrier(3, new CycliBarrierDemo());

    new Thread(new DataImportThread(cyclicBarrier,&quot;path1&quot;)).start();
    new Thread(new DataImportThread(cyclicBarrier,&quot;path2&quot;)).start();
    new Thread(new DataImportThread(cyclicBarrier,&quot;path3&quot;)).start();
&#125;
</code></pre>
<p>}</p>
<pre><code>结果
</code></pre>
<p>开始导入:path1位置的数据<br>开始导入:path2位置的数据<br>开始导入:path3位置的数据<br>开始进行数据分析</p>
<p>```</p>
<h6 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h6><ol>
<li>对于指定计数值 parties,若由于某种原因,没有足够的线程调用CyclicBarrier的await() ，则所有调用 await() 的线程都会被阻塞.</li>
<li>同样的CyclicBarrier 也可以调用 await(timeout,unit),设置超时时间,在设定的时候内,没有足够线程到达,则解除阻塞状态,继续工作.</li>
<li>通过rest重置计数,会使得进入await的线程出现BrokenBarrierException；</li>
<li>如果采用是CyclicBarrier(int parties,Runnable barrierAction) 构造方法,执行 barrierAction操作的最后一个到达线程.</li>
</ol>
<h5 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h5><p>CyclicBarrier 相比CountDownLatch 来说,简单很多,源码是基于ReentrantLock和Condition组合使用的.</p>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">luyanan</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://rainsoil.github.io/2022/01/04/bing-fa-bian-cheng/chang-jian-de-bing-fa-gong-ju-de-shi-yong-he-yuan-li-5/">https://rainsoil.github.io/2022/01/04/bing-fa-bian-cheng/chang-jian-de-bing-fa-gong-ju-de-shi-yong-he-yuan-li-5/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">luyanan</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            <span class="chip bg-color">无标签</span>
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2022/01/04/bing-fa-bian-cheng/bing-fa-bian-cheng-de-ji-ben-ren-shi-1/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/16.jpg" class="responsive-img" alt="并发编程的基本认识(1)">
                        
                        <span class="card-title">并发编程的基本认识(1)</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2022-01-04
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" class="post-category">
                                    并发编程
                                </a>
                            
                            <a href="/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" class="post-category">
                                    并发编程
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2022/01/04/bing-fa-bian-cheng/duo-xian-cheng-de-ji-ben-yuan-li-ji-tiao-zhan-2/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/19.jpg" class="responsive-img" alt="多线程的基本原理及挑战(2)">
                        
                        <span class="card-title">多线程的基本原理及挑战(2)</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2022-01-04
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" class="post-category">
                                    并发编程
                                </a>
                            
                            <a href="/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" class="post-category">
                                    并发编程
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>

    

    <div class="container row center-align"
         style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2019-2022</span>
            
            <a href="/about" target="_blank">luyanan</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
                &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                        class="white-color">803.3k</span>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/rainsoil" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:luyanan0718@163.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=914596513" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 914596513" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    

    

    <!-- 雪花特效 -->
    

    <!-- 鼠标星星特效 -->
    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    
    <script type="text/javascript" color="0,0,255"
        pointColor="0,0,255" opacity='0.7'
        zIndex="-1" count="99"
        src="/libs/background/canvas-nest.js"></script>
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
