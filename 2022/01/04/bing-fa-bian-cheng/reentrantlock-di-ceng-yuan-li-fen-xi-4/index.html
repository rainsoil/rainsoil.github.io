<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="ReentrantLock底层原理分析(4), railsoil">
    <meta name="description" content="
4. ReentrantLock底层原理分析J.U.C 简介java.util.concurrent是在并发编程中比较常用的工具类,里面包含很多用来在并发场景中使用的组件.比如线程池,阻塞队列,计时器,同步器,并发集合等.并发包的作者是大">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>ReentrantLock底层原理分析(4) | railsoil</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="railsoil" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>




<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">railsoil</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">railsoil</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        
    </ul>
</div>


        </div>

        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/7.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">ReentrantLock底层原理分析(4)</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                          <div class="article-tag">
                            <span class="chip bg-color">无标签</span>
                          </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" class="post-category">
                                并发编程
                            </a>
                        
                            <a href="/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" class="post-category">
                                并发编程
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2022-01-04
                </div>
                

                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    7.4k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    30 分
                </div>
                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">

        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <hr>
<h1 id="4-ReentrantLock底层原理分析"><a href="#4-ReentrantLock底层原理分析" class="headerlink" title="4. ReentrantLock底层原理分析"></a>4. ReentrantLock底层原理分析</h1><h2 id="J-U-C-简介"><a href="#J-U-C-简介" class="headerlink" title="J.U.C 简介"></a>J.U.C 简介</h2><p>java.util.concurrent是在并发编程中比较常用的工具类,里面包含很多用来在并发场景中使用的组件.比如线程池,阻塞队列,计时器,同步器,并发集合等.并发包的作者是大名鼎鼎的 Doug Lea.</p>
<h2 id="lock"><a href="#lock" class="headerlink" title="lock"></a>lock</h2><h3 id="Lock简介"><a href="#Lock简介" class="headerlink" title="Lock简介"></a>Lock简介</h3><p>在Lock接口出现之前,java中的应用程序对于多线程的并发安全处理只能基于synchronized 关键字来解决,但是 synchronized 在有些场景下会存在一些短板,也就是它不适用于所有的并发场景. 但是在java5之后,Lock的出现可以解决synchronized 在某些场景中的短板,它比synchronized 更加的灵活.</p>
<h3 id="Lock的实现"><a href="#Lock的实现" class="headerlink" title="Lock的实现"></a>Lock的实现</h3><p>Lock本质上是一个接口,它定义了释放和获取锁的抽象方法,定义成接口就意味着它定义了锁的一个标准规范,也同时意味着锁的不同实现.实现Lock接口类有很多,以下为几个常见的锁实现</p>
<p><strong>ReentrantLock</strong>: 表示重入锁,它是唯一实现了Lock接口的锁. 重入锁指的是线程在获得锁之后,再次获得锁不需要阻塞,而是直接关联一次计数器增加重入次数.</p>
<p><strong>ReentrantWriteReadLock</strong>: 重入读写锁,它实现了ReadWriteLock接口,在这个类中维护了两个类,一个是ReadLock,一个是WriteLock,他们都分别实现了Lock接口.读写锁是一种适合于读多写少的场景下解决线程安全问题的工具,基本原则是:读和读不互斥,读和写互斥,写和写互斥.也就是说影响数据变化的操作都会互斥.</p>
<p><strong>StampedLock:</strong> StampedLock 是JDK8引入的新的锁机制,可以简单认为是读写锁的一个改进版本,读写锁虽然可以通过分离读和写的功能使得读和读之间可以完全并发,但是读和写是有冲突的,如果大量的线程存在,可能会引起写线程的饥饿,StampedLock 是一种乐观的读策略,使得乐观锁完全不会阻塞写线程.</p>
<h3 id="Lock的类关系图"><a href="#Lock的类关系图" class="headerlink" title="Lock的类关系图"></a>Lock的类关系图</h3><p>Lock有很多的锁的实现,但是直观的实现是ReentrantLock 重入锁<br><img src="http://files.luyanan.com//img/20190729211742.png"></p>
<pre><code>      ReentrantLock lock = new ReentrantLock();
        //  如果锁可用就直接获得锁,如果不可用就直接阻塞
        lock.lock();
        //  和lock方法相似,但是阻塞的线程可中断,抛出InterruptedException 异常
        lock.lockInterruptibly();
        // 非阻塞获取锁,尝试获取锁,r如果成功返回true
        lock.tryLock();
        // 带有超时时间的获取锁的方法
        lock.tryLock(11, TimeUnit.DAYS);
        //释放锁
        lock.unlock();
</code></pre>
<h3 id="ReentrantLock-重入锁"><a href="#ReentrantLock-重入锁" class="headerlink" title="ReentrantLock 重入锁"></a>ReentrantLock 重入锁</h3><p>重入锁,表示支持重新进入的锁,也就是说,如果当前线程t1 通过调用lock方法获得了锁之后,再次调用lock,是不会再去阻塞去获取锁,直接增加重试次数就行了.synchronized 和ReentrantLock 都是可重入锁.很多人不理解为什么锁会存在重入的特性,那是因为对于同步锁的理解程度还不够.比如在下面这类的场景中,c存在多个加锁的方法的相互调用,其实就是一种重入特性的场景.</p>
<h4 id="重入锁的设计目的"><a href="#重入锁的设计目的" class="headerlink" title="重入锁的设计目的"></a>重入锁的设计目的</h4><p>比如调用demo方法获得了当前的对象锁,然后在这个方法中再去调用demo2,demo2中的存在同一个实例锁,这个时候当前线程会因为无法获得demo2的对象锁而阻塞, 就会产生死锁. 重入锁设计的目的就是为了避免线程的死锁.</p>
<pre><code>public class ReentrantLockDemo &#123;

    public static void main(String[] args) &#123;
        ReentrantLockDemo reentrantLockDemo = new ReentrantLockDemo();
        new Thread(reentrantLockDemo::demo).start();
    &#125;

    public synchronized void demo() &#123;
        System.out.println(&quot;begin demo&quot;);
        demo2();
    &#125;

    private synchronized void demo2() &#123;
        System.out.println(&quot;begin demo&quot;);
    &#125;

&#125;
</code></pre>
<p>ReentrantLock 的使用案例</p>
<pre><code>public class ReentrantLockDemo &#123;

    private static int count;

    static ReentrantLock lock = new ReentrantLock();

    public static void inc() &#123;


        try &#123;
            lock.lock();
            TimeUnit.MILLISECONDS.sleep(2);
            count++;
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
            lock.unlock();
        &#125;


    &#125;

    public static void main(String[] args) throws InterruptedException &#123;
        for (int i = 0; i &lt; 100; i++) &#123;
            new Thread(() -&gt; ReentrantLockDemo.inc()).start();
        &#125;
        TimeUnit.SECONDS.sleep(30);
        System.out.println(count);
    &#125;
    &#125;
</code></pre>
<h3 id="ReentrantWriteReadLock"><a href="#ReentrantWriteReadLock" class="headerlink" title="ReentrantWriteReadLock"></a>ReentrantWriteReadLock</h3><p>我们以前的理解的锁,基本上都是排他锁,也就是这些锁在同一时刻只允许一个线程进行访问,而读写锁在同一时刻可以允许多个线程访问,但是在写线程访问时,所有的读线程和写线程都会被阻塞. 读写锁维护了一堆锁,一个读锁,一个写锁;一般情况下,读写锁的性能都比排他锁强,因为大部分场景都是读多写少的. 在读多于写的情况下,读写锁能够提供比排他锁更好的并发量和吞吐量.</p>
<pre><code>package com.notes.concurrent.synchronizeds;

import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantReadWriteLock;

/**
 * @author luyanan
 * @since 2019/7/29
 * &lt;p&gt;读写锁&lt;/p&gt;
 **/
public class ReentrantWriteReadLockDemo &#123;

    static Map&lt;String, Object&gt; cache = new HashMap&lt;&gt;();


    static ReentrantReadWriteLock lock = new ReentrantReadWriteLock();
    static ReentrantReadWriteLock.ReadLock readLock = lock.readLock();
    static ReentrantReadWriteLock.WriteLock writeLock = lock.writeLock();

    public static final Object get(String key) &#123;
        System.out.println(&quot;开始读取数据&quot;);
        readLock.lock();
        try &#123;
            return cache.get(key);
        &#125; finally &#123;
            readLock.unlock();
        &#125;
    &#125;

    public static final Object put(String key, Object value) &#123;
        System.out.println(&quot;开始写数据&quot;);
        writeLock.lock();
        try &#123;
            return cache.put(key, value);
        &#125; finally &#123;
            writeLock.unlock();
        &#125;
    &#125;

&#125;
</code></pre>
<p>在这个案例中,通过hashmap 来模拟了一个内存缓存,然后使用读写锁来保证这个内存缓存d的线程安全性.当执行读操作的时候,需要获取读锁,在并发访问的时候,读锁不会阻塞,因为读锁不会影响执行结果.</p>
<p>在执行写操作的时候,线程必须获取写锁,当已有线程持有写锁的情况下,当前线程会被阻塞,只有当写锁释放后,其他读写操作才能继续执行. 使用读写锁提升了读操作的并发性,也保证了每次写操作对所有读写操作的可见性.</p>
<ul>
<li>读锁和读锁共享</li>
<li>读锁和写锁不可以共享(排他)</li>
<li>写锁和写锁不可以共享(排他)</li>
</ul>
<h3 id="ReentrantLock-的实现原理"><a href="#ReentrantLock-的实现原理" class="headerlink" title="ReentrantLock 的实现原理"></a>ReentrantLock 的实现原理</h3><p>我们知道锁的基本原理是基于将多线程并行任务通过某一种机制实现线程的串行执行,从而达到线程安全性的目的. 在synchronized 中 ,我们分析了偏向锁,轻量级锁,乐观锁以及自旋锁来优化了synchronized 的加锁开销,同时在重量级锁阶段,通过线程的阻塞以及唤醒来达到线程竞争和同步的目的. 那么在ReentrantLock中,也一定会存在这样的需求去解决问题,就是在多线程竞争重入锁的时候,竞争失败的线程是如何阻塞和被 唤醒的呢？</p>
<h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><h4 id="AQS是什么？"><a href="#AQS是什么？" class="headerlink" title="AQS是什么？"></a>AQS是什么？</h4><p>在Lock中 用到了一个同步队列AQS,全称 AbstractQueuedSynchronizer,它是一个同步工具也是Lock用来实现线程同步的核心组件. 如果你搞懂了AQS，那么J.U.C 中的绝大部分的工具你都能掌握.</p>
<h4 id="AQS的两种功能"><a href="#AQS的两种功能" class="headerlink" title="AQS的两种功能"></a>AQS的两种功能</h4><p>从使用层面上来说,AQS的功能分为两种:独占和共享</p>
<p>独占锁,每次只能有一个线程持有锁,比如前面演示的ReentrantLock 就是以独占方式实现的互斥锁.</p>
<p>共享锁:允许多个线程同时获取锁,并发访问共享资源,比如ReenteantWriteReadLock</p>
<h4 id="AQS的内部实现"><a href="#AQS的内部实现" class="headerlink" title="AQS的内部实现"></a>AQS的内部实现</h4><p>AQS内部维护的是一个FIFO的双向链表,这种结构的特点是每个数据结构都有两个指针,分别指向直接的后继节点和直接前驱节点. 所以双向链表可以从任意一个节点开始很方便的访问前驱和后继. 每个Node其实是由线程封装,当线程抢占锁失败后就会被封装成Node节点加入到AQS队列中. 当获取锁的线程释放锁以后,会从队列中唤醒一个阻塞的节点(线程)</p>
<p><img src="http://files.luyanan.com//img/20190731213443.jpg"></p>
<h4 id="Node的组成"><a href="#Node的组成" class="headerlink" title="Node的组成"></a>Node的组成</h4><pre><code>static final class Node &#123;
        /** Marker to indicate a node is waiting in shared mode */
        static final Node SHARED = new Node();
        /** Marker to indicate a node is waiting in exclusive mode */
        static final Node EXCLUSIVE = null;

        /** waitStatus value to indicate thread has cancelled */
        static final int CANCELLED =  1;
        /** waitStatus value to indicate successor&#39;s thread needs unparking */
        static final int SIGNAL    = -1;
        /** waitStatus value to indicate thread is waiting on condition */
        static final int CONDITION = -2;
        /**
         * waitStatus value to indicate the next acquireShared should
         * unconditionally propagate
         */
        static final int PROPAGATE = -3;

       
        volatile int waitStatus;

       // 前置节点
        volatile Node prev;

        // 后继节点 
        volatile Node next;

        /**
         * The thread that enqueued this node.  Initialized on
         * construction and nulled out after use.
         */
         // 当前线程
        volatile Thread thread;

// 存储在condition队列中的后继节点
        Node nextWaiter;

        /**
         * Returns true if node is waiting in shared mode.
         */
         // 是否为共享锁
        final boolean isShared() &#123;
            return nextWaiter == SHARED;
        &#125;

        /**
         * Returns previous node, or throws NullPointerException if null.
         * Use when predecessor cannot be null.  The null check could
         * be elided, but is present to help the VM.
         *
         * @return the predecessor of this node
         */
        final Node predecessor() throws NullPointerException &#123;
            Node p = prev;
            if (p == null)
                throw new NullPointerException();
            else
                return p;
        &#125;

        Node() &#123;    // Used to establish initial head or SHARED marker
        &#125;

     // 将线程构造成一个Node,添加到等待队列
        Node(Thread thread, Node mode) &#123;     // Used by addWaiter
            this.nextWaiter = mode;
            this.thread = thread;
        &#125;

      // 这个方法会在Condition 中用到
        Node(Thread thread, int waitStatus) &#123; // Used by Condition
            this.waitStatus = waitStatus;
            this.thread = thread;
        &#125;
    &#125;
</code></pre>
<h4 id="释放锁以及添加线程对于队列的变化"><a href="#释放锁以及添加线程对于队列的变化" class="headerlink" title="释放锁以及添加线程对于队列的变化"></a>释放锁以及添加线程对于队列的变化</h4><p>当出现锁竞争以及释放锁的时候, AQS 同步队列中的节点会发生变化,首先看一下添加节点的场景<br><img src="http://files.luyanan.com//img/20190731213400.jpg"><br>里面会涉及两个变化</p>
<ol>
<li>新的线程封装成Node节点追加到同步队列中,设置prev节点以及修改当前节点的前置节点d的next 指向自己。</li>
<li>通过CAS将tail 重新指向新的尾部节点</li>
</ol>
<p>head节点表示获得锁成功的节点,当头节点在释放同步状态的时候,会唤醒后继节点,如果后继节点获得锁成功,会将自己设置为头节点,节点的变化过程如下:<br><img src="http://files.luyanan.com//img/20190731215144.jpg"><br>这个过程也设涉及两个变化</p>
<ol>
<li>修改head节点指向下一个获得锁的节点</li>
<li>新的获得锁的节点,将prev的节点设置为null</li>
</ol>
<p>设置head节点不需要用CAS,原因是设置head节点是由获得锁的线程来完成的,而同步锁只能由一个线程获取,所以不需要CAS保证,只需要把head节点设置为原首节点的后继节点,并且断开与原head节点的next引用即可.</p>
<h3 id="ReentrantLock-的源码分析"><a href="#ReentrantLock-的源码分析" class="headerlink" title="ReentrantLock 的源码分析"></a>ReentrantLock 的源码分析</h3><p>以ReentrantLock 作为切入点,来看看在这个场景下是如何使用AQS来实现线程同步的</p>
<h4 id="ReentrantLock的时序图"><a href="#ReentrantLock的时序图" class="headerlink" title="ReentrantLock的时序图"></a>ReentrantLock的时序图</h4><p>调用ReentrantLock的lock()方法<br><img src="http://files.luyanan.com//img/20190802215141.jpg"><br><strong>ReentrantLock.lock()</strong></p>
<p>这个是ReentrantLock获取锁的入口</p>
<pre><code>   public void lock() &#123;
        sync.lock();
    &#125;
</code></pre>
<p>syn实际上是一个抽象的静态内部类,它继承了AQS来实现重入锁的逻辑.我们前面说过AQS是一个同步队列,他能够实现线程的阻塞以及唤醒,但是它并不具备业务功能,所以在不同的同步场景中,会继承AQS来实现对应场景的功能.</p>
<p>Sync有两个具体的实现:</p>
<ul>
<li>NonfairSync: 表示可以存在抢占锁的功能,也就是说不管当前队列上是否有其他线程等待,新线程都有机会抢占锁.</li>
<li>FairSync:表示所有线程都严格按照FIFO来获取锁.</li>
</ul>
<h4 id="NonfairSync-lock"><a href="#NonfairSync-lock" class="headerlink" title="NonfairSync.lock()"></a>NonfairSync.lock()</h4><p>以非公平锁为例,来看看lock中的实现</p>
<ol>
<li>非公平锁和公平锁的最大的区别在于,在非公平锁中我抢占锁的逻辑是 不管有没有线程排队,我先上来cas 去抢占一下.</li>
<li>CAS成功,就表示成功获得了锁.</li>
<li>CAS失败,就调用 acquire(1); 走锁竞争逻辑</li>
</ol>
<pre><code>    final void lock() &#123;
            if (compareAndSetState(0, 1))
                setExclusiveOwnerThread(Thread.currentThread());
            else
                acquire(1);
        &#125;
</code></pre>
<p>CAS的实现逻辑</p>
<pre><code>   protected final boolean compareAndSetState(int expect, int update) &#123;
        // See below for intrinsics setup to support this
        return unsafe.compareAndSwapInt(this, stateOffset, expect, update);
    &#125;
</code></pre>
<p>通过cas 乐观锁的方式来做比较并替换,这段代码的意思是,如果当前内存中的state的值于预期值expect 相等,则替换update.更新成功则返回true,否则返回false.</p>
<p>这个操作是原子的,不会出现线程安全的问题,这里面涉及到了Unsafe的操作,以及涉及到state 这个属性的意思.</p>
<p>state是AQS中的一个属性, 它在不同的实现中所表达的含义是不一样的,对于重入锁的实现来说,它表示一个同步状态.它有两个含义的表示:</p>
<ol>
<li>当state =0时,表示无锁状态.</li>
<li>当state &gt;0时,表示已有线程获得了锁,也就是state =1,但是因为ReentrantLock 允许重入,所以同一个线程多次获得同步锁的时候,state 就会递增,比如重入5次,那么state = 5; 而在释放锁的时候,同样需要释放5次知道state = 0 其他线程才有资格获得锁.</li>
</ol>
<h6 id="Unsafe类"><a href="#Unsafe类" class="headerlink" title="Unsafe类"></a>Unsafe类</h6><p>Unsafe累是在sun.misc 包下,不属于java标准.但是在很多的java的基础类库中,包括以下被广泛使用的高性能的开发库都是基于Unfafe类开发的,比如 Netty,Hadoop,Kafka等.</p>
<p>Unsafe可以被认为是java中留下的后门,提供了一些低层次的操作,如直接内存访问,线程的挂起和恢复,CAS,线程的同步,内存屏障等.</p>
<p>而CAS 就是Unsafe类中提供的一个原子操作,第一个参数为需要改变的对象,第二个为偏移量(即之前求出来的headOffset的值),第三个参数为期待的值,第四个为更新后的值。</p>
<p>整个方法的作用是如果当前的值于预期的值var4相等,则更新为新的期望的值var5, 如果更新成功,则返回true,否则返回false.</p>
<h6 id="stateOffset"><a href="#stateOffset" class="headerlink" title="stateOffset"></a>stateOffset</h6><p>一个java对象可以看做是一段内存,每个字段都得按照一定的顺序放在这段内存里,通过这个方法可以准确的告诉你某个字段相对于对象的起始内存地址的字节偏移.用于在后面的 compareAndSwapInt 中,去根据偏移量找到对象在内存中的具体位置.</p>
<p>所以stateOffset 表示state 这个字段在AQS 类的内存中相对于该类首地址的偏移量</p>
<h6 id="compareAndSwapInt"><a href="#compareAndSwapInt" class="headerlink" title="compareAndSwapInt"></a>compareAndSwapInt</h6><p>在 unsafe.cpp中,可以找到 compareAndSwapInt 的实现</p>
<pre><code>UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSwapInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x))
  UnsafeWrapper(&quot;Unsafe_CompareAndSwapInt&quot;);
  oop p = JNIHandles::resolve(obj); // 将java对象解析成JVM的oop(普通对象指针)
  jint* addr = (jint *) index_oop_from_field_offset_long(p, offset);// 根据对象p和地址偏移量找到地址
  return (jint)(Atomic::cmpxchg(x, addr, e)) == e; // 基于cas比较并替换,x表示需要更新的值,addr表示state在内存中的值,e 表示预期值
UNSAFE_END
</code></pre>
<h6 id="AQS-acquire"><a href="#AQS-acquire" class="headerlink" title="AQS.acquire"></a>AQS.acquire</h6><p>acquire 是AQS中的方法,如果CAS 操作未能成功,说明state 已经不为0了,此时继续acquire(1)操作</p>
<blockquote>
<p>大家思考一下,acquire 方法中的1的参数是用来做什么的?</p>
</blockquote>
<pre><code>    public final void acquire(int arg) &#123;
        if (!tryAcquire(arg) &amp;&amp;
            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
            selfInterrupt();
    &#125;
</code></pre>
<p>这个方法的主要逻辑是:</p>
<ol>
<li>通过tryAcquire 尝试获取独占锁,如果成功返回true,如果失败返回false</li>
<li>如果tryAcquire 失败,则会通过 addWaiter  方法将当前线程封装成Node节点添加到AQS 队列尾部.</li>
<li>acquireQueued 将Node作为参数,通过自旋去尝试获得锁.</li>
</ol>
<h6 id="NonfairSync-tryAcquire"><a href="#NonfairSync-tryAcquire" class="headerlink" title="NonfairSync.tryAcquire"></a>NonfairSync.tryAcquire</h6><pre><code>       protected final boolean tryAcquire(int acquires) &#123;
            return nonfairTryAcquire(acquires);
        &#125;
</code></pre>
<p>这个方法的作用的尝试获取锁,如果成功则返回true,如果失败则返回false, 它是重写AQS类中的tryAcquire 方法,并且大家仔细看一下 AQS中的tryAcquire 方法的定义,并没有实现,而是抛出异常.按照一般的思维模式,既然是一个不实现的模板方法,那应该定位是abstract, 让子类来实现?</p>
<h6 id="ReentrantLock-nonfairTryAcquire"><a href="#ReentrantLock-nonfairTryAcquire" class="headerlink" title="ReentrantLock.nonfairTryAcquire"></a>ReentrantLock.nonfairTryAcquire</h6><pre><code>    final boolean nonfairTryAcquire(int acquires) &#123;
            // 获得当前执行的线程
            final Thread current = Thread.currentThread();
            // 获得state 值
            int c = getState();
            if (c == 0) &#123; // 表示无锁状态
                if (compareAndSetState(0, acquires)) &#123;// cas替换 state的值,如果cas成功表示获得锁成功
                    // 保存当前获得锁的线程,下次再来的时候就不再尝试竞争锁
                    setExclusiveOwnerThread(current);
                    return true;
                &#125;
            &#125;
            //  如果同一个线程来获得锁,直接增加重入次数
            else if (current == getExclusiveOwnerThread()) &#123;
                int nextc = c + acquires;
                if (nextc &lt; 0) // overflow
                    throw new Error(&quot;Maximum lock count exceeded&quot;);
                setState(nextc);
                return true;
            &#125;
            return false;
        &#125;
</code></pre>
<ol>
<li>获得当前线程,判断当前锁的状态</li>
<li>如果state=1 表示当前是无锁状态,通过cas 更新state状态的值</li>
<li>当前线程是属于重入,则增加重入次数</li>
</ol>
<h6 id="AQS-addWaiter"><a href="#AQS-addWaiter" class="headerlink" title="AQS.addWaiter"></a>AQS.addWaiter</h6><pre><code> private Node addWaiter(Node mode) &#123;
        Node node = new Node(Thread.currentThread(), mode);
        // Try the fast path of enq; backup to full enq on failure
        // tail是AQS中表示同比队列队尾的属性,默认为null
        Node pred = tail;
        // tail 不为空的情况下,说明队列中存在节点
        if (pred != null) &#123;
            // 把当前线程的Node的prev 指向tail
            node.prev = pred;
            //  通过cas把Node节点加入到AQS队列中,也就是设置为tail
            if (compareAndSetTail(pred, node)) &#123;
                // 设置成功后,把原tail节点的next指向当前node
                 pred.next = node;
                return node;
            &#125;
        &#125;
        // tail = null,把node添加到同步队列
        enq(node);
        return node;
    &#125;
</code></pre>
<p>当tryAcquire 方法获得锁失败之后,则会先调用 addWaiter 将当前线程封装成Node</p>
<p>入参mode表示当前节点的状态,传递的参数是Node.EXCLUSIVE,表示独占状态,意味着重入锁用到了AQS的独占锁功能.</p>
<ol>
<li>将当前线程封装成Node</li>
<li>当前链表中的tail节点是否为空,如果不为空,则通过cas操作把当前线程的node节点添加到CAS 队列</li>
<li>如果为空或者cas失败,调用enq 将节点添加到AQS 队列</li>
</ol>
<h6 id="enq"><a href="#enq" class="headerlink" title="enq"></a>enq</h6><p>enq 就是通过自旋把当前节点加入到队列中</p>
<pre><code>    private Node enq(final Node node) &#123;
        for (;;) &#123;
            Node t = tail;
            if (t == null) &#123; // Must initialize
                if (compareAndSetHead(new Node()))
                    tail = head;
            &#125; else &#123;
                node.prev = t;
                if (compareAndSetTail(t, node)) &#123;
                    t.next = node;
                    return t;
                &#125;
            &#125;
        &#125;
    &#125;
</code></pre>
<h5 id="图解分析"><a href="#图解分析" class="headerlink" title="图解分析"></a>图解分析</h5><p>假设3个线程来争抢锁,那么截至到enq方法运行结束之后,或者调用addWaiter()方法结束后,AQS中的链表结构<br><img src="http://files.luyanan.com//img/20190806134628.jpg"></p>
<h6 id="AQS-acquireQueued"><a href="#AQS-acquireQueued" class="headerlink" title="AQS.acquireQueued"></a>AQS.acquireQueued</h6><pre><code> final boolean acquireQueued(final Node node, int arg) &#123;
        boolean failed = true;
        try &#123;
            boolean interrupted = false;
            for (;;) &#123;
                //  获得当前节点的prev节点
                final Node p = node.predecessor();
                // 如果是nead节点,说明有资格去争抢锁
                if (p == head &amp;&amp; tryAcquire(arg)) &#123;
                    // 获得锁成功,也就是ThreadA 已经释放了锁,然后设置head为ThreadB 获得执行权限
                    setHead(node);
                    // 把原head 节点从链表中移除
                    p.next = null; // help GC
                    failed = false;
                    return interrupted;
                &#125;
                // ThreadA 可能还没有释放锁,使得ThreadB 在执行 tryAcquire时就会返回false
                if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;
                    parkAndCheckInterrupt())
                    // 并且返回当前线程在等待过程中有没有中断过
                    interrupted = true;
            &#125;
        &#125; finally &#123;
            if (failed)
                cancelAcquire(node);
        &#125;
    &#125;
</code></pre>
<p>通过addWaiter 方法把线程添加到链表后,会接着把Node作为参数传递给acquireQueued 方法中去竞争锁.</p>
<ol>
<li>获得当前节点的prev节点</li>
<li>如果prev 节点为head节点,那么它就有资格去争抢锁,调用tryAcquire 抢占锁.</li>
<li>抢占锁成功之后,把获得锁的节点设置为head, 并且移除原来的初始化head 节点</li>
<li>如果获得锁失败,根据waitStatus决定是否要挂起锁.</li>
<li>最后,通过cancelAcquire 取消获得锁的操作.</li>
</ol>
<h6 id="NofairSync-tryAcquire"><a href="#NofairSync-tryAcquire" class="headerlink" title="NofairSync.tryAcquire"></a>NofairSync.tryAcquire</h6><p>这个方法在前面分析过,就是通过state 的状态来判断是否处于无锁状态,然后再通过cas进行竞争锁操作. 成功表示获得锁,失败表示获得锁失效.</p>
<h6 id="shouldParkAfterFailedAcquire"><a href="#shouldParkAfterFailedAcquire" class="headerlink" title="shouldParkAfterFailedAcquire"></a>shouldParkAfterFailedAcquire</h6><pre><code>private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123;
        // 前置节点的waitStatus
        int ws = pred.waitStatus;
        // 如果前置节点为SIGNAL, 意味着只需要等待其他前置节点的线程被释放
        if (ws == Node.SIGNAL)
            /*
             * This node has already set status asking a release
             * to signal it, so it can safely park.
             */
            // 返回true,意味着可以直接放心的挂起了.
            return true;
            // ws 大于0 意味着prev节点取消了 排队,直接移除这个节点就行了
        if (ws &gt; 0) &#123;
            /*
             * Predecessor was cancelled. Skip over predecessors and
             * indicate retry.
             */
            do &#123;
                // 相当于: pred = pred.prev;  node.prev = pred;
                node.prev = pred = pred.prev;
                //  这里采用循环,从双向列表中移除 CANCELLED的节点
            &#125; while (pred.waitStatus &gt; 0);
            pred.next = node;
            // 利用cas设置prev节点的状态为 SIGNAL
        &#125; else &#123;
            /*
             * waitStatus must be 0 or PROPAGATE.  Indicate that we
             * need a signal, but don&#39;t park yet.  Caller will need to
             * retry to make sure it cannot acquire before parking.
             */
            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);
        &#125;
        return false;
    &#125;
</code></pre>
<p>如果ThreadA的锁还没有释放的情况下,ThreadB 和ThreadC 来争抢锁 肯定是会失败,那么失败后还调用shouldParkAfterFailedAcquire 方法.</p>
<p>Node 有5种状态,分别是 CANCELLED（1），SIGNAL（-1）、CONDITION（-<br>2）、PROPAGATE(-3)、默认状态(0)</p>
<p><strong>CANCELLED:</strong> 在同步队列中等待的线程等待超时或者中断,需要从同步队列中取消该Node的节点,其节点的waitStatus 为 CANCELLED, 即结束状态,进入该状态的节点将不会再变化.</p>
<p><strong>SIGNAL:</strong> 只要前置节点释放锁,就会通知标识为SIGNAL状态的后续节点的线程<br><strong>CONDITION:</strong> 和Condition 有关系.<br><strong>PROPAGATE:</strong> 共享模式下,PROPAGATE状态的线程处于可运行状态,0: 初始状态.</p>
<p>这个方法的主要作用是通过Node的状态来判断ThreadA 竞争锁失败以后是否应该被挂起.</p>
<ol>
<li>如果ThreadA 的pred 节点状态为SIGNAL, 那就表示可以放心的挂起当前线程</li>
<li>通过循环扫描链表把 CANCELLED 状态的节点移除</li>
<li>修改pred 节点的状态为 SIGNAL,返回false<blockquote>
<p> 返回fasle时,也就是不需要挂起,返回true, 则需要调用 shouldParkAfterFailedAcquire  挂起当前线程.</p>
</blockquote>
</li>
</ol>
<h6 id="parkAndCheckInterrupt"><a href="#parkAndCheckInterrupt" class="headerlink" title="parkAndCheckInterrupt"></a>parkAndCheckInterrupt</h6><pre><code>    private final boolean parkAndCheckInterrupt() &#123;
        LockSupport.park(this);
        return Thread.interrupted();
    &#125;
</code></pre>
<p> 使用LockSupport.park 挂起当前线程为 WATING 状态.</p>
<p> Thread.interrupted()  返回当前线程是否被其他线程触发过中断请求,也就是thread.interrupt(); 如果有触发过中断请求,那么这个方法会返回当前的中断标识true, 并且对中断标识进行复位标识已经响应过的中断请求.如果返回true,意味着在acquire方法中执行 selfInterrupt().</p>
<h6 id="selfInterrupt"><a href="#selfInterrupt" class="headerlink" title="selfInterrupt"></a>selfInterrupt</h6><pre><code> static void selfInterrupt() &#123;
       Thread.currentThread().interrupt();
   &#125;
</code></pre>
<p> 标识如果当前线程在 acquireQueued 中被中断过,则需要产生一个中断请求,原因是线程在调用 acquireQueued 方法的时候是不会响应中断请求的</p>
<h6 id="图解分析-1"><a href="#图解分析-1" class="headerlink" title="图解分析"></a>图解分析</h6><p> 通过 acquireQueued 方法来竞争锁, 如果ThreadA  还在执行中没有释放锁的话,意味着ThreadB 和ThreadC 只能挂起了.</p>
<p> <img src="http://files.luyanan.com//img/20190806150744.png"></p>
<h5 id="LockSupport"><a href="#LockSupport" class="headerlink" title="LockSupport"></a>LockSupport</h5><p> LockSupport 类是java6 引入的一个类,提供了基本的线程同步原语.LockSupport 实际上是调用了 Unsafe类里面的函数,归结到Unsafe 里面,只有两个函数</p>
<pre><code>  /**
    * Unblock the given thread blocked on &lt;tt&gt;park&lt;/tt&gt;, or, if it is
    * not blocked, cause the subsequent call to &lt;tt&gt;park&lt;/tt&gt; not to
    * block.  Note: this operation is &quot;unsafe&quot; solely because the
    * caller must somehow ensure that the thread has not been
    * destroyed. Nothing special is usually required to ensure this
    * when called from Java (in which there will ordinarily be a live
    * reference to the thread) but this is not nearly-automatically
    * so when calling from native code.
    * @param thread the thread to unpark.
    *
    */
   public native void unpark(Object thread);

   /**
    * Block current thread, returning when a balancing
    * &lt;tt&gt;unpark&lt;/tt&gt; occurs, or a balancing &lt;tt&gt;unpark&lt;/tt&gt; has
    * already occurred, or the thread is interrupted, or, if not
    * absolute and time is not zero, the given time nanoseconds have
    * elapsed, or if absolute, the given deadline in milliseconds
    * since Epoch has passed, or spuriously (i.e., returning for no
    * &quot;reason&quot;). Note: This operation is in the Unsafe class only
    * because &lt;tt&gt;unpark&lt;/tt&gt; is, so it would be strange to place it
    * elsewhere.
    */
   public native void park(boolean isAbsolute, long time);
</code></pre>
<p> unpark 函数为线程提供了”许可(permit)” ,线程调用park函数则等待”许可”.这个有点像信号量,但是这个”许可” 是不能叠加的,”许可”是一次性的.</p>
<p> permit 相当于0/1的开关, 默认是0, 调用一次unpark 就加1 变成了1,调用一个park 就会消费permit, 又会变成0. 如果再调用一次 park就会阻塞,因为permit 已经是0了,知道permit 变成1 ,这时调用unpark 会把 permit 设置为1.每个线程都已经一个相关的permit, permit最多只有一个,重复调用unpark 不会累计.</p>
<h3 id="锁的释放流程"><a href="#锁的释放流程" class="headerlink" title="锁的释放流程"></a>锁的释放流程</h3><p> 如果这个时候 ThreadA 释放锁了,那么我们来看看锁被释放够会产生什么效果.</p>
<h6 id="ReentrantLock-unlock"><a href="#ReentrantLock-unlock" class="headerlink" title="ReentrantLock.unlock"></a>ReentrantLock.unlock</h6><pre><code> public void unlock() &#123;
       sync.release(1);
   &#125;
</code></pre>
<p> 在unlock 中,会调用 release 方法来释放锁</p>
<pre><code>   public final boolean release(int arg) &#123;
       // 释放锁成功
       if (tryRelease(arg)) &#123;
           // 得到aqs中的头部节点
           Node h = head;
           // 如果head节点不为空并且状态!=0 调用unparkSuccessor(h); 唤醒后续的节点
           if (h != null &amp;&amp; h.waitStatus != 0)
               unparkSuccessor(h);
           return true;
       &#125;
       return false;
   &#125;
</code></pre>
<h6 id="ReentrantLock-tryRelease"><a href="#ReentrantLock-tryRelease" class="headerlink" title="ReentrantLock.tryRelease"></a>ReentrantLock.tryRelease</h6><pre><code>     protected final boolean tryRelease(int releases) &#123;
            int c = getState() - releases;
            if (Thread.currentThread() != getExclusiveOwnerThread())
                throw new IllegalMonitorStateException();
            boolean free = false;
            if (c == 0) &#123;
                free = true;
                setExclusiveOwnerThread(null);
            &#125;
            setState(c);
            return free;
        &#125;
</code></pre>
<p>这个方法可以认为是一个设置锁状态的操作,通过将state状态减掉传入的参数值(参数值为1),如果结果状态为0,就想排它锁的Owner设置为null, 使得其他线程有机会进行.</p>
<p>在排它锁中,加锁的时候的状态会增加1(当然可以自己修改这个值),在解锁的时候减掉1,同一个锁,在可以重入后,可能会被叠加为2、3、4这些值,只有unlock() 的次数和lock()的次数对应才会将Owner线程设置为空,而且也只有这种情况下,才会返回true.</p>
<h6 id="unparkSuccessor"><a href="#unparkSuccessor" class="headerlink" title="unparkSuccessor"></a>unparkSuccessor</h6><pre><code>  private void unparkSuccessor(Node node) &#123;
        /*
         * If status is negative (i.e., possibly needing signal) try
         * to clear in anticipation of signalling.  It is OK if this
         * fails or if status is changed by waiting thread.
         */
        // 获得head 节点的状态
        int ws = node.waitStatus;
        if (ws &lt; 0)
            // 设置head节点状态为0
            compareAndSetWaitStatus(node, ws, 0);

        /*
         * Thread to unpark is held in successor, which is normally
         * just the next node.  But if cancelled or apparently null,
         * traverse backwards from tail to find the actual
         * non-cancelled successor.
         */
        // 得到head节点的下一个节点
        Node s = node.next;
        if (s == null || s.waitStatus &gt; 0) &#123;
           // 如果下一个节点为null或者status&gt;0  表示cancelled 状态,
            // 通过从尾部节点开始扫描,找到距离head最近的一个waitStatus&lt;=0的节点
            s = null;
            for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)
                if (t.waitStatus &lt;= 0)
                    s = t;
        &#125;
        // next节点不为空,直接唤醒这个线程即可.
        if (s != null)
            LockSupport.unpark(s.thread);
    &#125;
</code></pre>
<p><strong>为什么在释放锁的时候是从tail 进行扫描的呢?</strong></p>
<p>我们再回到enq这个方法 来看一下一个新的节点是如何加入到链表中的</p>
<ol>
<li>将新的节点的prev 指向tail</li>
<li>通过cas将tail设置为新的节点, 因为cas是原子操作 所以能够保证线程安全性.</li>
<li>t.next = node; 设置 原tail 的next节点指向新的节点</li>
</ol>
<pre><code>    private Node enq(final Node node) &#123;
        for (;;) &#123;
            Node t = tail;
            if (t == null) &#123; // Must initialize
                if (compareAndSetHead(new Node()))
                    tail = head;
            &#125; else &#123;
                node.prev = t;
                if (compareAndSetTail(t, node)) &#123;
                    t.next = node;
                    return t;
                &#125;
            &#125;
        &#125;
    &#125;
</code></pre>
<p><img src="http://files.luyanan.com//img/20190806171752.png"></p>
<p>在cas操作之后,t.next=node 操作之前.存在其他线程调用 unlock 方法从 head开始往后遍历,由于t.next=nodel 还没执行 ,意味着链表的关系还没有建立完整,就会导致遍历到t 节点的时候被中断.所有从后往前遍历,一定不会存在这个问题。</p>
<h6 id="图解分析-2"><a href="#图解分析-2" class="headerlink" title="图解分析"></a>图解分析</h6><p>通过锁的释放,原本的结构就发生了一些变化.head节点的waitStatus 变成了0,ThreadB被唤醒.</p>
<p><img src="http://files.luyanan.com//img/20190806172259.jpg"></p>
<h5 id="原本挂起的线程执行"><a href="#原本挂起的线程执行" class="headerlink" title="原本挂起的线程执行"></a>原本挂起的线程执行</h5><p>通过ReentrantLock.unlock ,原本挂起的线程是在acquireQueued 方法中,被唤醒之后从这个方法开始执行.</p>
<h6 id="AQS-acquireQueued-1"><a href="#AQS-acquireQueued-1" class="headerlink" title="AQS.acquireQueued"></a>AQS.acquireQueued</h6><pre><code>final boolean acquireQueued(final Node node, int arg) &#123;
        boolean failed = true;
        try &#123;
            boolean interrupted = false;
            for (;;) &#123;
                final Node p = node.predecessor();
                if (p == head &amp;&amp; tryAcquire(arg)) &#123;
                    setHead(node);
                    p.next = null; // help GC
                    failed = false;
                    return interrupted;
                &#125;
                if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;
                    parkAndCheckInterrupt())
                    interrupted = true;
            &#125;
        &#125; finally &#123;
            if (failed)
                cancelAcquire(node);
        &#125;
    &#125;
</code></pre>
<p>这个方法前面已经分析过了,我们只关注一下ThreadB 被唤醒以后的执行流程.</p>
<p>由于ThreadB的 prev 节点指向的是head, 并且ThreadA 已经释放锁,所以这个时候调用tryAcquire 方法时 就可以顺利获取到锁。</p>
<ol>
<li>把ThreadB节点当成head</li>
<li>把原head节点的next节点指向null</li>
</ol>
<h6 id="图解分析-3"><a href="#图解分析-3" class="headerlink" title="图解分析"></a>图解分析</h6><ol>
<li>设置新head 节点的prev 为null</li>
<li>设置原head节点的next节点为null<br><img src="http://files.luyanan.com//img/20190806214413.jpg"></li>
</ol>
<h3 id="公平锁和非公平锁的区别"><a href="#公平锁和非公平锁的区别" class="headerlink" title="公平锁和非公平锁的区别"></a>公平锁和非公平锁的区别</h3><p>锁的公平性是相对于获取锁的顺序而言的,如果是一个公平锁,那么获取锁的顺序j就应该符合请求的绝对时间排序,也就是FIFO。 在上面的例子来说,只要CAS设置成功,则表示当前线程获得了锁,而公平锁则不一样，差异点有两个</p>
<h6 id="FairSync-tryAcquire"><a href="#FairSync-tryAcquire" class="headerlink" title="FairSync.tryAcquire"></a>FairSync.tryAcquire</h6><p>非公平锁在获得锁的时候,会先通过CAS进行抢占,而公平锁则不会.</p>
<pre><code>final void lock() &#123;
            acquire(1);
        &#125;
        
           protected final boolean tryAcquire(int acquires) &#123;
            final Thread current = Thread.currentThread();
            int c = getState();
            if (c == 0) &#123;
                if (!hasQueuedPredecessors() &amp;&amp;
                    compareAndSetState(0, acquires)) &#123;
                    setExclusiveOwnerThread(current);
                    return true;
                &#125;
            &#125;
            else if (current == getExclusiveOwnerThread()) &#123;
                int nextc = c + acquires;
                if (nextc &lt; 0)
                    throw new Error(&quot;Maximum lock count exceeded&quot;);
                setState(nextc);
                return true;
            &#125;
            return false;
        &#125;
</code></pre>
<p>这个方法与nonfairTryAcquire(int acquires) 比较,不同的地方在于判断条件多了 hasQueuedPredecessors 方法,也就是加入了[同步队列中当前节点是否有前驱节点] 的判断,如果该方法返回true,则表示有线程比当前 线程更早的请求获取锁,因为需要等待前驱线程获取并释放锁之后才能继续获得锁.</p>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">luyanan</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://rainsoil.github.io/2022/01/04/bing-fa-bian-cheng/reentrantlock-di-ceng-yuan-li-fen-xi-4/">https://rainsoil.github.io/2022/01/04/bing-fa-bian-cheng/reentrantlock-di-ceng-yuan-li-fen-xi-4/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">luyanan</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            <span class="chip bg-color">无标签</span>
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2022/01/04/an-zhuang/centos-an-zhuang-nfs/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/21.jpg" class="responsive-img" alt="centos安装nfs">
                        
                        <span class="card-title">centos安装nfs</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2022-01-04
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E5%AE%89%E8%A3%85/" class="post-category">
                                    安装
                                </a>
                            
                            <a href="/categories/%E5%AE%89%E8%A3%85/%E5%AE%89%E8%A3%85/" class="post-category">
                                    安装
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2022/01/04/an-zhuang/centos-7-yum-fang-shi-an-zhuang-mysql5.7/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/9.jpg" class="responsive-img" alt="centos 7 yum方式安装Mysql5">
                        
                        <span class="card-title">centos 7 yum方式安装Mysql5</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2022-01-04
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E5%AE%89%E8%A3%85/" class="post-category">
                                    安装
                                </a>
                            
                            <a href="/categories/%E5%AE%89%E8%A3%85/%E5%AE%89%E8%A3%85/" class="post-category">
                                    安装
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>

    

    <div class="container row center-align"
         style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2019-2022</span>
            
            <a href="/about" target="_blank">luyanan</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
                &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                        class="white-color">803.3k</span>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/rainsoil" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:luyanan0718@163.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=914596513" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 914596513" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    

    

    <!-- 雪花特效 -->
    

    <!-- 鼠标星星特效 -->
    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    
    <script type="text/javascript" color="0,0,255"
        pointColor="0,0,255" opacity='0.7'
        zIndex="-1" count="99"
        src="/libs/background/canvas-nest.js"></script>
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
